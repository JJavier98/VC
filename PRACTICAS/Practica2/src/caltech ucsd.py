# -*- coding: utf-8 -*-
"""Práctica2-ejer3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HHCA8b-CbtYv_z7SEPGCcarETTfCl4Hu
"""

from google.colab import drive
drive.mount('/content/drive')

!unzip /content/drive/My\ Drive/VC/imagenes.zip -d /content

# Importar librerías necesarias
import numpy as np
import keras
import keras.utils as np_utils
from keras.preprocessing.image import load_img
from keras.preprocessing.image import img_to_array
import matplotlib.pyplot as plt
from keras.models import Sequential # Modulos
from keras.layers import Dense, Dropout, Flatten, ReLU # Capas
from keras.layers import Conv2D, MaxPooling2D, BatchNormalization # Capas
from keras.models import Model
from  keras.applications.resnet  import  ResNet50 ,preprocess_input
from keras.preprocessing.image import ImageDataGenerator
# Importar el optimizador a usar
from keras.optimizers import Adam

#########################################################################
################## FUNCIÓN PARA LEER LAS IMÁGENES #######################
#########################################################################

# Dado un fichero train.txt o test.txt y el path donde se encuentran los
# ficheros y las imágenes, esta función lee las imágenes
# especificadas en ese fichero y devuelve las imágenes en un vector y 
# sus clases en otro.

def leerImagenes(vec_imagenes, path):
  clases = np.array([img.split('/')[0] for img in vec_imagenes])
  imagenes = np.array([img_to_array(load_img(path + "/" + img, 
                                             target_size = (224, 224))) 
                       for img in vec_imagenes])
  return imagenes, clases

#########################################################################
############# FUNCIÓN PARA CARGAR EL CONJUNTO DE DATOS ##################
#########################################################################

# Usando la función anterior, y dado el path donde se encuentran las
# imágenes y los archivos "train.txt" y "test.txt", devuelve las 
# imágenes y las clases de train y test para usarlas con keras
# directamente.

def cargarDatos(path):
  # Cargamos los ficheros
  train_images = np.loadtxt(path + "/train.txt", dtype = str)
  test_images = np.loadtxt(path + "/test.txt", dtype = str)
  
  # Leemos las imágenes con la función anterior
  train, train_clases = leerImagenes(train_images, path)
  test, test_clases = leerImagenes(test_images, path)
  
  # Pasamos los vectores de las clases a matrices 
  # Para ello, primero pasamos las clases a números enteros
  clases_posibles = np.unique(np.copy(train_clases))
  for i in range(len(clases_posibles)):
    train_clases[train_clases == clases_posibles[i]] = i
    test_clases[test_clases == clases_posibles[i]] = i

  # Después, usamos la función to_categorical()
  train_clases = np_utils.to_categorical(train_clases, 200)
  test_clases = np_utils.to_categorical(test_clases, 200)
  
  # Barajar los datos
  train_perm = np.random.permutation(len(train))
  train = train[train_perm]
  train_clases = train_clases[train_perm]

  test_perm = np.random.permutation(len(test))
  test = test[test_perm]
  test_clases = test_clases[test_perm]
  
  return train, train_clases, test, test_clases

#########################################################################
## FUNCIÓN PARA PINTAR LA PÉRDIDA Y EL ACCURACY EN TRAIN Y VALIDACIÓN ###
#########################################################################

# Esta función pinta dos gráficas, una con la evolución de la función
# de pérdida en el conjunto de train y en el de validación, y otra
# con la evolución del accuracy en el conjunto de train y en el de
# validación. Es necesario pasarle como parámetro el historial
# del entrenamiento del modelo (lo que devuelven las funciones
# fit() y fit_generator()).

def mostrarEvolucion(hist):

  loss = hist.history['loss']
  val_loss = hist.history['val_loss']
  plt.plot(loss)
  plt.plot(val_loss)
  plt.legend(['Training loss', 'Validation loss'])
  plt.show()

  acc = hist.history['acc']
  val_acc = hist.history['val_acc']
  plt.plot(acc)
  plt.plot(val_acc)
  plt.legend(['Training accuracy', 'Validation accuracy'])
  plt.show()


#########################################################################
######## FUNCIÓN PARA OBTENER EL ACCURACY DEL CONJUNTO DE TEST ##########
#########################################################################

# Esta función devuelve el accuracy de un modelo, definido como el 
# porcentaje de etiquetas bien predichas frente al total de etiquetas.
# Como parámetros es necesario pasarle el vector de etiquetas verdaderas
# y el vector de etiquetas predichas, en el formato de keras (matrices
# donde cada etiqueta ocupa una fila, con un 1 en la posición de la clase
# a la que pertenece y 0 en las demás).

def calcularAccuracy(labels, preds):
  labels = np.argmax(labels, axis = 1)
  preds = np.argmax(preds, axis = 1)
  
  accuracy = sum(labels == preds)/len(labels)
  
  return accuracy

x_train, y_train, x_test, y_test = cargarDatos('/content/imagenes')
batch_size = 32
optimizador = Adam()

print(x_train.shape)

datagen = ImageDataGenerator(preprocessing_function=preprocess_input)

datagen_test = ImageDataGenerator(preprocessing_function=preprocess_input)

resnet50 = ResNet50(include_top = False ,weights ='imagenet', pooling ='avg')
predicted_train = resnet50.predict_generator(datagen.flow(x_train, y_train, batch_size = batch_size,
                                    shuffle = False),
                                    verbose=1)
predicted_test = resnet50.predict_generator(datagen_test.flow(x_test, y_test, batch_size = batch_size,
                                    shuffle = False),
                                    verbose=1)

modelo_dense = Sequential()
modelo_dense.add(Dense(400, activation = 'relu'))
modelo_dense.add(Dense(200, activation = 'softmax'))

modelo_dense.compile(loss=keras.losses.categorical_crossentropy,
              optimizer=optimizador,
              metrics=['accuracy'])

historia = modelo_dense.fit(predicted_train, y_train,
                    epochs = 40,
                    batch_size= 32,
                    validation_split=0.1,
                    verbose=1)

mostrarEvolucion(historia)

score = modelo_dense.evaluate(predicted_test, y_test, verbose=1)
print('Test loss:', score[0])
print('Test accuracy:', score[1])

##############################################
##############################################
##############################################
##############################################
resnet50_2 = ResNet50(include_top = False ,weights ='imagenet', pooling ='avg')
x = resnet50_2.output
x = Dense(400, activation = 'relu')(x)
last = Dense(200, activation = 'softmax')(x)

new_model = Model(inputs = resnet50_2.input, outputs = last)

new_model.compile(loss=keras.losses.categorical_crossentropy,
              optimizer=optimizador,
              metrics=['accuracy'])

datagen = ImageDataGenerator(validation_split = 0.1,
                             preprocessing_function=preprocess_input)

datagen_test = ImageDataGenerator(preprocessing_function=preprocess_input)

datagen.fit(x_train)
datagen_test.fit(x_train)

historia = new_model.fit_generator(datagen.flow(x_train ,y_train, batch_size = batch_size, subset='training'),
                    validation_data = datagen.flow(x_train, y_train ,batch_size = batch_size, subset='validation'),
                    epochs = 40,
                    steps_per_epoch = len(x_train)*0.9/batch_size,
                    validation_steps = len(x_train )*0.1/batch_size)
